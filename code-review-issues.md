# Project Code Review – OneManVanFSM Mobile & Web – 2025-06-18

## Summary
The OneManVanFSM solution is a .NET 10 MAUI Blazor Hybrid mobile app with an ASP.NET Core Blazor Server web project and a shared EF Core + SQLite data layer. The codebase demonstrates competent architecture with dual-mode (local/remote) operation, PBKDF2 password hashing, JWT-based API authentication, and a well-structured entity model with ~35 entities and comprehensive relationship mapping. However, this exhaustive review reveals **critical security vulnerabilities** (hardcoded credentials in committed files, TLS bypass, IDOR exposure on every API endpoint, destructive schema migration), **significant database integrity gaps** (missing indexes, no concurrency tokens, orphan risk, no data validation attributes), **data loss risks** (full DB deletion on schema drift, hard-delete operations), and **architectural concerns** (scoped DbContext as singleton-lifetime in MAUI, no migration framework, no input sanitization on API endpoints). Risk level: **High** for production deployment — the app functions for a single-user demo, but security, data integrity, and multi-device sync scenarios carry unacceptable risk.

---

## Critical Issues

| # | Severity | Description | Location | Impact | Evidence |
|---|----------|-------------|----------|--------|----------|
| C1 | **CRITICAL** | **Hardcoded admin credentials in committed .env file.** The `.env` file contains `ADMIN_PASSWORD=!1235aSdf12sadf5!` and `SYNC_PASSWORD=YourSecureSyncPassword123!`. While `.env` is gitignored, the `.env` file currently exists in the workspace and the same password is hardcoded in `MauiProgram.cs` line 261 inside `EnsureAdminUserExists()`: `PasswordHash = MobileAuthService.HashPassword("!1235aSdf12sadf5!")`. This password is compiled into the binary. Anyone decompiling the APK can extract it. Additionally, `.env.development` and `.env.production` files are present and may not be gitignored — they could contain production secrets. | `MauiProgram.cs:261`, `.env:14,19`, `.env.development`, `.env.production` | **Full admin access to any installation** — the default admin password is embedded in every compiled binary. An attacker who decompiles the Android APK can login as Owner on any OneManVanFSM instance that hasn't changed the default password. |
| C2 | **CRITICAL** | **TLS certificate validation completely disabled.** `ApiClient.cs` line 52 sets `ServerCertificateCustomValidationCallback = (_, _, _, _) => true`, unconditionally accepting ALL certificates including self-signed, expired, and MITM certificates. This is not gated behind a `#if DEBUG` check — it runs in Release builds. Any attacker on the same network can intercept all API traffic (including JWT tokens and passwords) via a MITM attack. | `ApiClient.cs:49-53` | **Complete exposure of all API traffic** — JWT tokens, passwords, customer data, and financial data can be intercepted by any network-level attacker. This includes sync operations that transmit the entire database. |
| C3 | **CRITICAL** | **Destructive schema migration deletes entire database.** `EnsureSchemaUpToDate()` in `MauiProgram.cs` lines 187-201 compares the EF model against SQLite PRAGMA table_info, and if ANY column is missing, calls `context.Database.EnsureDeleted()` — destroying ALL data. After an app update that adds a single column to any entity, every user's local database (customers, jobs, invoices, time entries) is permanently deleted with no backup, no export, no warning. | `MauiProgram.cs:187-201 (EnsureSchemaUpToDate), 200 (EnsureDeleted)` | **Total data loss on schema change** — any app update that adds or renames a model property will silently destroy the user's entire local database. For a field service app where the database IS the business data, this is catastrophic. |
| C4 | **CRITICAL** | **Insecure Direct Object Reference (IDOR) on all API endpoints.** Every sync API controller (Jobs, Customers, Invoices, Expenses, TimeEntries, etc.) inherits from `SyncApiController` which requires JWT Bearer auth, but NO endpoint validates that the authenticated user has permission to access the requested resource. Any authenticated user can: (a) GET all customers, all invoices, all expenses via `/api/customers`, `/api/invoices`, etc.; (b) UPDATE any record via PUT; (c) DELETE (archive) any record. The `DashboardApiController.GetDashboard` accepts `employeeId` as a route parameter with an `elevated` query flag — any user can pass `elevated=true` to see all data. | `SyncApiController.cs` (base), all controllers in `OneManVanFSM.Web\Controllers\` | **Any authenticated user can read/modify/delete any other user's data.** A Tech-role user could view Owner financials, modify customer records, or archive jobs belonging to other employees. |
| C5 | **CRITICAL** | **JWT signing key is deterministic and guessable.** When `JWT_SECRET` environment variable is not set (which is the default for local development and any deployment that doesn't explicitly configure it), `JwtService.GenerateStableKey()` derives the signing key from `SHA256("OneManVanFSM-{MachineName}-SyncApi")`. An attacker who knows the machine name (often visible in network discovery or HTTP headers) can forge valid JWT tokens granting any role, including Admin. The machine name derivation is also not cryptographically random — it's a fixed hash of a known format. | `JwtService.cs:85-90 (GenerateStableKey)` | **JWT token forgery** — any attacker who knows or can guess the server hostname can create valid JWT tokens with any role (Owner, Admin), gaining full API access to create, read, update, and delete all business data. |

---

## High Issues

| # | Severity | Description | Location | Impact | Evidence |
|---|----------|-------------|----------|--------|----------|
| H1 | **HIGH** | **DbContext lifetime mismatch in MAUI.** `AppDbContext` is registered as `AddDbContext<AppDbContext>` (scoped) in `MauiProgram.cs:55-56`, but in MAUI Blazor, "scoped" means the entire app lifetime (there is no per-request scope like in ASP.NET). This means a single `AppDbContext` instance lives for the entire app session, accumulating tracked entities in the change tracker, leading to: (a) stale data reads (cached entities not reflecting DB changes from sync), (b) memory growth as tracked entity count climbs, (c) potential `InvalidOperationException` when multiple operations try to track the same entity. The `AsNoTracking()` calls on read paths mitigate reads, but all write operations track entities indefinitely. | `MauiProgram.cs:55-56` | Memory leaks and stale data in long-running app sessions. Write operations may fail with tracking conflicts after extended use. |
| H2 | **HIGH** | **No concurrency control on entity updates.** No entity in the entire model defines a `[ConcurrencyCheck]` or `[Timestamp]` attribute, and no EF Core `IsRowVersion()` is configured. While the sync API controllers implement a basic `UpdatedAt` comparison for conflict detection (e.g., `CustomersApiController.cs:53`), the local mobile service operations (`MobileJobService.UpdateJobStatusAsync`, `MobileNoteService.UpdateNoteAsync`, etc.) perform `FindAsync` → modify → `SaveChangesAsync` with no optimistic concurrency check. If two devices sync simultaneously and modify the same record, last-write-wins with no conflict detection or notification. | All model classes (no `[Timestamp]` attribute), all mobile service Update methods | **Silent data loss** in multi-device scenarios — the last sync overwrites all previous changes with no merge or conflict notification. |
| H3 | **HIGH** | **AuditLog entity has no foreign key configuration and is never written in mobile app.** `AuditLog` has `UserId` pointing to `AppUser`, but `AppDbContext.OnModelCreating` only configures indexes — no explicit FK relationship, and critically no `OnDelete` behavior. More importantly, the `AuditLog` table is NEVER written to in the mobile app — no CRUD operation (create, update, delete customer/job/invoice/note) creates an audit entry. Audit logging only exists in `OneManVanFSM.Web` (`ReportService.cs`). This means all mobile operations are completely unauditable. | `AuditLog.cs:14-15` (FK nav property), `AppDbContext.cs:487-491` (only indexes), absence of `db.AuditLogs.Add()` in any mobile service | **No audit trail for mobile operations** — deletions, status changes, financial modifications made from the mobile app have no record. Compliance and dispute resolution are impossible. |
| H4 | **HIGH** | **Hard-delete operations in mobile services bypass archival pattern.** `MobileNoteService.DeleteNoteAsync()` (line 71) calls `db.QuickNotes.Remove(note)` — a permanent hard delete. Similarly, `MobileDocumentService` and `MobileExpenseService` likely hard-delete records. However, the sync API controllers use soft-delete (`customer.IsArchived = true`). This inconsistency means: (a) mobile deletes are unrecoverable, (b) hard-deleted records cannot be synced back as "deleted" to the server — the server still has the record while mobile doesn't, causing sync conflicts. | `MobileNoteService.cs:71-74 (db.QuickNotes.Remove)` | **Data permanently lost on mobile delete** — no soft-delete, no archive, no undo, no sync reconciliation for deleted records. |
| H5 | **HIGH** | **No input validation or sanitization on API endpoints.** All API controllers accept full entity objects via `[FromBody]` deserialization with no `[Required]`, `MaxLength`, or custom validation. For example, `JobsApiController.Create` accepts a full `Job` object — an attacker could set arbitrary values for `CreatedAt`, `CompletedDate`, or even navigation properties. No model has `[Required]`, `[StringLength]`, or `[Range]` data annotation attributes. The EF model relies entirely on database-level constraints (which for SQLite are minimal — no CHECK constraints, no string length limits). | All API controllers `Create`/`Update` methods, all entity models (no data annotations) | **Malicious data injection** — an attacker can craft API requests with overlong strings, negative monetary values, or logically invalid data (e.g., `ScheduledDate` in 1900, negative `HourlyRate`, or XSS payloads in text fields). |
| H6 | **HIGH** | **Login endpoint returns 200 OK for failed logins.** `AuthApiController.Login()` returns `Ok(ApiLoginResponse.Failure(...))` for all failure cases (invalid password, locked account, inactive user). HTTP 200 with a failure payload means: (a) brute-force detection tools that monitor for HTTP 401/403 won't detect attacks, (b) WAF/reverse proxy rules based on status codes won't apply, (c) rate limiting based on error status codes won't trigger. | `AuthApiController.cs:54,57,60,68` — all return `Ok(...)` | Brute-force password attacks against the API are difficult to detect at the infrastructure level since all responses return HTTP 200. |
| H7 | **HIGH** | **Sync credential exposed via plain-text comparison.** `AuthApiController.cs:39-40` compares the sync password using `request.Password == syncPassword` — a direct string comparison that is vulnerable to timing attacks. While the regular user path uses `VerifyPassword` with `CryptographicOperations.FixedTimeEquals`, the sync account password is compared with basic `==` operator. Additionally, the sync password comes from environment variables and is transmitted in plain text over HTTP (see C2 — TLS bypass). | `AuthApiController.cs:38-40` | Timing attack on sync password — an attacker can determine the sync password character-by-character by measuring response times. |
| H8 | **HIGH** | **No rate limiting on any API endpoint.** There is no rate limiting middleware, no `[RateLimit]` attribute, no throttling of any kind on the REST API. The login endpoint (`/api/authapi/login`) has a per-user lockout after 5 attempts, but there is no IP-based or global rate limit. An attacker can make unlimited requests to all data endpoints, potentially exfiltrating the entire database through the sync endpoints. | `OneManVanFSM.Web\Program.cs` (no rate limiting middleware), all controllers | **Denial-of-service and data exfiltration** — unlimited API requests with no throttling. |
| H9 | **HIGH** | **Login endpoint anti-forgery disabled.** `Program.cs:155` uses `.DisableAntiforgery()` on the `/auth/login` POST endpoint. While this was likely done because the form uses `<form method="post">` from server-side Blazor, it opens the endpoint to cross-site request forgery attacks. Any malicious website could submit a login form to the OneManVanFSM instance. | `OneManVanFSM.Web\Program.cs:155` | CSRF attack on login — an attacker can force a victim's browser to submit login credentials to a OneManVanFSM server. |
| H10 | **HIGH** | **Notification badge and count computed from full dashboard reload.** `MobileLayout.razor` calls dashboard/inventory/estimates/agreements services on every `OnInitializedAsync` — every page navigation triggers 4+ database queries just to compute a badge count. There is no caching, no event-driven update, no lightweight count endpoint. For the remote mode, this means 4+ API round-trips on every page load. | `MobileLayout.razor` (OnInitializedAsync badge computation) | **Performance degradation** — every page navigation incurs unnecessary database queries. In remote mode, this adds latency to every navigation. |
| H11 | **HIGH** | **No pagination on sync API endpoints.** All sync GET endpoints (Jobs, Customers, Invoices, etc.) return ALL records matching the query with no pagination. `SyncResponse` model has `Page`/`PageSize` in `SyncRequest` but the controllers never use them. For a business with thousands of jobs/invoices, the sync response could be multi-megabyte JSON payloads, causing timeouts, OOM exceptions, or mobile network failures. | All API controllers `GetAll` methods (e.g., `JobsApiController.cs:17-25`), `SyncRequest.cs:47-48` (pagination fields exist but unused) | **Sync failure at scale** — businesses with >1000 records per entity type will experience sync timeouts or memory exhaustion. |

---

## Medium Issues

| # | Severity | Description | Location | Impact |
|---|----------|-------------|----------|--------|
| M1 | **MEDIUM** | **No database migration framework.** The project uses `EnsureCreated()` and destructive `EnsureDeleted()` — there is no `dotnet ef migrations` folder, no migration history table, no `MigrationBuilder`. Schema evolution is handled by deleting and recreating the entire database. This is acceptable only for prototyping, never for production with real data. | `MauiProgram.cs:143,200`, `OneManVanFSM.Web\Program.cs:187` | Production deployments cannot evolve the schema without data loss. |
| M2 | **MEDIUM** | **EmployeeRole and UserRole enums are separate but semantically identical.** `Employee.Role` uses `EmployeeRole` (Owner, Admin, Dispatcher, Tech, Manager, Apprentice) while `AppUser.Role` uses `UserRole` (Owner, Admin, Dispatcher, Tech, Manager). `Apprentice` exists in `EmployeeRole` but not `UserRole`, meaning an Apprentice employee cannot have a matching user role. The permission system uses `UserRole`, so role-to-feature mapping for `Apprentice` users is undefined — the `PermissionService` will return `CanView=false` for all features. | `Employee.cs:36-44 (EmployeeRole)`, `AppUser.cs:24-31 (UserRole)` | Apprentice employees cannot log in with a matching role. Role mismatches between Employee and AppUser records will cause permission lookup failures. |
| M3 | **MEDIUM** | **Job.Priority uses `Standard` but was previously referenced as `Normal` in CSS.** The `JobPriority` enum defines `Standard` (line 69 of `Job.cs`), but the previous QA fix added `.priority-normal` CSS class. The code generates CSS class `priority-@job.Priority.ToString().ToLower()` which would yield `priority-standard`. If the CSS fix added `.priority-normal` instead of `.priority-standard`, the mismatch persists. | `Job.cs:69 (JobPriority.Standard)`, `wwwroot\app.css` | Priority dots may still not render correctly if CSS class name doesn't match enum value. |
| M4 | **MEDIUM** | **Seed data EntityId hardcoded to assumed IDs.** `MauiProgram.SeedMobileData` sets `qn1.EntityId = 1` (line 422) and `qn2.EntityId = 4` (line 434) assuming that `job1` will get `Id=1` and `job4` will get `Id=4`. However, SQLite auto-increment doesn't guarantee sequential IDs starting from 1, especially after a `EnsureDeleted()`+`EnsureCreated()` cycle where the ROWID sequence may not reset. | `MauiProgram.cs:422,434` | Seed data QuickNotes may reference wrong jobs via EntityId, causing incorrect note-to-job associations in demo mode. |
| M5 | **MEDIUM** | **No index on foreign key columns used in WHERE clauses.** Multiple FK columns used in frequent queries have no explicit index: `TimeEntry.EmployeeId` (queried on every dashboard load), `QuickNote.CreatedByEmployeeId`, `QuickNote.JobId`, `Expense.EmployeeId`, `Expense.JobId`, `Document.JobId`, `Document.CustomerId`. EF Core creates indexes for FK relationships by convention when they're configured in `OnModelCreating`, but `TimeEntry.EmployeeId` is configured via `HasOne/WithMany` which does create an implicit FK index. However, composite queries like `WHERE EmployeeId = X AND EntryType = Y AND EndTime IS NULL` would benefit from a composite index. | `AppDbContext.cs` (no composite indexes), query patterns in `MobileDashboardService.cs`, `MobileTimeService.cs` | Query performance degrades as data volume grows, particularly for dashboard and time entry queries. |
| M6 | **MEDIUM** | **OfflineQueueService stores entire mutation payloads in MAUI Preferences as JSON.** `Preferences.Default.Set(PrefsKey, json)` (line 149) serializes the entire queue (including full entity JSON payloads) into a single Preferences string. MAUI Preferences on Android uses SharedPreferences, which has a practical limit of ~1MB per value. A queue with many large entity mutations (e.g., Assets with 80+ fields) could exceed this limit, causing silent data loss or crashes. | `OfflineQueueService.cs:144-150` | Offline queue corruption or silent data loss when queue grows large. |
| M7 | **MEDIUM** | **ReplayPostAsync always returns true regardless of server response.** `OfflineQueueService.ReplayPostAsync()` (line 112) calls `_api.PostAsync<JsonElement>()` and unconditionally returns `true`. If the server returns an error (400, 409 conflict, 500), the queue item is still marked as processed and removed. Failed mutations are silently discarded. | `OfflineQueueService.cs:107-113` | **Silent data loss** — failed offline mutations are dropped without retry or notification. |
| M8 | **MEDIUM** | **No foreign key from Invoice back to Job is configured in OnModelCreating.** The `Invoice` model has `JobId`/`Job` nav properties (lines 41-42), and `Job` has `InvoiceId`/`Invoice` (lines 39-40). The relationship is configured from the `Job` side as `HasOne(j => j.Invoice).WithOne(inv => inv.Job).HasForeignKey<Job>(j => j.InvoiceId)`. This means `Invoice.JobId` is an UNMAPPED shadow property from EF's perspective — it's on the model but the FK is actually on `Job.InvoiceId`. If code sets `invoice.JobId = X`, it won't create the bidirectional relationship — only `job.InvoiceId` is the actual FK. | `Invoice.cs:41-42`, `Job.cs:39-40`, `AppDbContext.cs:153-156` | Confusing bidirectional FK — setting `Invoice.JobId` doesn't establish the relationship. Code that relies on `Invoice.JobId` for navigation may find null `Invoice.Job`. |
| M9 | **MEDIUM** | **Password strength requirements are weak.** `CompleteFirstTimeSetupAsync` (line 206) only checks `newPassword.Length < 6`. No complexity requirements (uppercase, lowercase, digit, special character). The hardcoded admin password `!1235aSdf12sadf5!` is moderately strong, but the validation permits passwords like "123456" or "aaaaaa". | `MobileAuthService.cs:206-207`, `Setup.razor` | Weak passwords — users can set trivially guessable passwords. |
| M10 | **MEDIUM** | **No HTTPS enforcement in web project.** `Program.cs` does not call `app.UseHsts()` or `app.UseHttpsRedirection()` — not even conditionally for production. Combined with the Kestrel default binding on HTTP port 8080 in Docker (`Dockerfile:28`), all web traffic (including cookie-authenticated sessions and API tokens) travels unencrypted. | `OneManVanFSM.Web\Program.cs` (no HTTPS middleware), `Dockerfile:28 (http://+:8080)` | All web and API traffic unencrypted in production Docker deployment. |
| M11 | **MEDIUM** | **SyncService PullAndMerge uses brittle EF.Property cast pattern.** `SyncService.PullAndMerge<T>` (line 192-195) casts `DbSet<T>` entries to `object` and then uses `EF.Property<int>(e, "Id")` — this relies on every entity having an `int` property named `Id`. While currently all entities follow this convention, the pattern is fragile and will throw at runtime if any entity uses a different PK name or type. | `SyncService.cs:190-195` | Runtime exception if any entity model deviates from the `Id` convention. |
| M12 | **MEDIUM** | **CDN dependency for Bootstrap Icons.** `index.html` line 11 loads Bootstrap Icons from `cdn.jsdelivr.net`. If the CDN is unreachable (offline mode, network restriction, CDN outage), all icons in the app render as empty squares. For a mobile field service app that may operate in areas with poor connectivity, this is a reliability concern. The main Bootstrap CSS is loaded locally (`lib/bootstrap/dist/css/bootstrap.min.css`) but icons are external. | `wwwroot\index.html:11` | All icons disappear when offline or CDN is unreachable. |
| M13 | **MEDIUM** | **Background sync fire-and-forget with no error surfacing.** `RemoteMobileAuthService.LoginAsync` line 72-76 fires a background sync via `Task.Run` with no way to report errors to the user. If the initial sync fails (network error, auth issue, schema mismatch), the user sees a successful login but has an empty local database. There's no retry, no error notification, and no way to manually trigger the sync from the login flow. | `RemoteMobileAuthService.cs:72-76` | Users in remote mode may login successfully but have no data — with no indication of why or how to fix it. |
| M14 | **MEDIUM** | **No UpdatedAt timestamp on TimeEntry model.** Every other entity has `UpdatedAt` for sync conflict detection, but `TimeEntry` only has `CreatedAt` (line 19). The sync API's delta query uses `WHERE CreatedAt > since` for time entries (line 23 in `TimeEntriesApiController`), meaning modified time entries (e.g., clock-out updating Hours and EndTime) are NOT picked up by delta sync — only newly created entries sync. | `TimeEntry.cs` (no `UpdatedAt` property), `TimeEntriesApiController.cs:23` | **Modified time entries don't sync** — if a time entry is created and later clocked out (EndTime set), the delta sync won't pick up the clock-out change because `CreatedAt` hasn't changed. |
| M15 | **MEDIUM** | **Expense.Total is not computed — it's a manual property.** The `Expense` model has `Amount`, `TaxAmount`, and `Total` as separate properties with no computed relationship. If code sets `Amount=100` and `TaxAmount=8` but forgets to set `Total=108`, the Total will be wrong (default 0). There's no setter logic, no computed column, no EF `HasComputedColumnSql`. Same issue exists for `Invoice` (Subtotal, TaxAmount, Total) and `Estimate`. | `Expense.cs:8-10`, `Invoice.cs:11-13,17`, `Estimate.cs:18,22` | **Financial calculation errors** — any code path that modifies Amount/Tax without recomputing Total will create data integrity issues in invoices, estimates, and expenses. |

---

## Low / Informational

| # | Description | Location | Impact |
|---|-------------|----------|--------|
| L1 | **Debug logging exposes sensitive data.** `MobileAuthService.cs:30` logs the username in plain text. `MobileAuthService.cs:43` logs the first 20 characters of the password hash. `ApiClient.cs:84` logs the username during authentication. `MauiProgram.cs:46,52` logs the database file path. While these are `Debug.WriteLine` calls, they persist in Android logcat and are accessible to any app with READ_LOGS permission. | `MobileAuthService.cs:30,43`, `ApiClient.cs:84`, `MauiProgram.cs:46,52` | Sensitive data exposure via system logs. |
| L2 | **`desktop.css` referenced in `index.html` but may not exist.** Line 13 of `index.html` references `desktop.css`, but this is the MAUI mobile project's `wwwroot` — desktop CSS may not be applicable or may not exist, generating a 404 on load. | `wwwroot\index.html:13` | Console 404 error on every page load; unnecessary network request. |
| L3 | **Multiple entities use `DateTime.UtcNow` as default value in property initializers.** Properties like `CreatedAt = DateTime.UtcNow` are evaluated at object instantiation time, not at database insertion time. If an entity is created, held in memory for 5 minutes, then saved, `CreatedAt` will be 5 minutes before the actual save. This is a minor accuracy issue but affects audit timestamps. | All entity models (e.g., `Job.cs:25-26`, `Customer.cs:28-29`, `Invoice.cs:33-34`) | Minor timestamp inaccuracy for entities held in memory before saving. |
| L4 | **SyncService error log capped at 100 entries with no persistence.** `SyncService._errorLog` is an in-memory `List<SyncErrorEntry>` capped at 100 entries (lines 101-103). The log is lost when the app is closed. For diagnosing sync issues after an app restart, there is no persistent error log. | `SyncService.cs:31,101-103` | Sync error history lost on app restart — makes debugging sync failures difficult. |
| L5 | **QuickNote EntityId/EntityType is a polymorphic FK without type safety.** `QuickNote` uses `EntityType` (string) + `EntityId` (int) as a generic foreign key pattern, but also has explicit `CustomerId` and `JobId` FK properties. This creates ambiguity — a note can have `EntityType="Job"`, `EntityId=5`, AND `JobId=5` redundantly, or worse, `EntityType="Job"`, `EntityId=5`, `JobId=3` (contradictory). The seed data (line 422) sets both `EntityId=1` AND `Job=job1`, creating redundancy. | `QuickNote.cs:9-10,22-25`, `MauiProgram.cs:422` | Data integrity risk — redundant FK paths can become contradictory. |
| L6 | **No `.env.development` or `.env.production` in `.gitignore`.** The `.gitignore` ignores `.env` but the `file_search` shows `.env.development` and `.env.production` exist as open files. If these contain secrets and are not gitignored, they will be committed. | `.gitignore:14`, `.env.development`, `.env.production` | Potential secret exposure in version control. |
| L7 | **Invoice one-to-one with Job creates artificial constraint.** `Job.InvoiceId` is configured as `HasOne(j => j.Invoice).WithOne(inv => inv.Job)`, meaning each Invoice can only be linked to one Job and vice versa. However, real-world FSM scenarios often have multiple invoices per job (progress billing, change orders) or a single invoice covering multiple jobs. | `AppDbContext.cs:153-156`, `Job.cs:39-40` | Business logic constraint — cannot create multiple invoices for one job or combine jobs into one invoice. |
| L8 | **No validation that Employee referenced by TimeEntry exists before clock-in.** `MobileTimeService.ShiftClockInAsync` checks `db.Employees.FindAsync(employeeId)` but there's a TOCTOU race — the employee could be deleted between the check and the insert. The FK constraint will catch this, but the error message will be a raw EF exception, not a user-friendly message. | `MobileTimeService.cs:33-36` | Poor UX on edge-case FK violations — raw exception instead of friendly error. |
| L9 | **No health check for SQLite database integrity.** There is no `PRAGMA integrity_check` or equivalent in the startup sequence. If the SQLite database becomes corrupted (e.g., unexpected app kill during write, storage full), the app will crash with unhandled exceptions rather than detecting and reporting the corruption. | `MauiProgram.cs` (no integrity check) | Silent data corruption — no detection or recovery for corrupt SQLite databases. |
| L10 | **Dual JwtService instantiation in Program.cs.** `Program.cs:64` creates `new JwtService()` directly to configure JWT validation parameters, and line 45 registers `JwtService` via DI. This means two separate `JwtService` instances exist — if the `GenerateStableKey()` is non-deterministic (it is deterministic based on machine name, so this is currently safe), tokens generated by one instance might not validate in the other. The direct instantiation bypasses DI and is an anti-pattern. | `OneManVanFSM.Web\Program.cs:45,64` | Maintenance risk — if `JwtService` constructor gains dependencies, the direct `new JwtService()` will break. |
| L11 | **AssetLink delete behavior asymmetry.** `AssetLink.AssetId` uses `Cascade` delete, but `AssetLink.LinkedAssetId` uses `Restrict`. Deleting an asset will cascade-delete its links FROM other assets, but attempting to delete an asset that is the TARGET of links will throw a `DbUpdateException`. This asymmetry may not be intentional and creates confusing delete failures. | `AppDbContext.cs:344-351` | Delete operation fails with cryptic error when trying to remove an asset that is referenced as a LinkedAsset by other assets. |
| L12 | **ServiceAgreement.SiteId is in the model but NOT configured with FK relationship in OnModelCreating.** The `ServiceAgreement` entity has `public int? SiteId { get; set; }` and `public Site? Site { get; set; }` (lines 33-34), but `AppDbContext` only configures `Customer` and `Company` FKs for ServiceAgreement (lines 414-424). `SiteId` will be handled by EF convention, but with default delete behavior (which may be `Cascade` in some providers), creating a potential cascade issue. | `ServiceAgreement.cs:33-34`, `AppDbContext.cs:414-425` | Implicit FK relationship — delete behavior is provider-dependent rather than explicitly controlled. |
| L13 | **Expense, Document, and Asset soft-delete inconsistency.** API controllers use `IsArchived = true` for soft-delete, but mobile services call `db.Remove()` for hard-delete (QuickNotes). Some entities have `IsArchived` (Customers, Jobs, Invoices) but the mobile services' delete methods may not consistently use soft-delete vs hard-delete. | Various mobile services `Delete*Async` methods | Inconsistent delete behavior between mobile and web — some deletes are recoverable, others are permanent. |
| L14 | **AppUser.Email has unique index but no format validation.** The `AppUser.Email` property has a unique database index (`AppDbContext.cs:479`) but no email format validation anywhere — not in the model (no `[EmailAddress]` attribute), not in the auth service, not in the API. A user can be created with `Email = "not-an-email"` and it will be saved. | `AppUser.cs:7`, `AppDbContext.cs:479` | Invalid email addresses stored in the database. |
| L15 | **DashboardApiController uses `DateTime.UtcNow.Date` for "today" while mobile uses `DateTime.Now.Date`.** The web API dashboard uses `DateTime.UtcNow.Date` (line 25) for "today" comparisons, but the mobile `MobileDashboardService` uses `DateTime.Now.Date` (line 11). When the mobile syncs dashboard data from the API and compares locally, the "today" boundary may differ, causing inconsistent job counts between local and remote modes. | `DashboardApiController.cs:25`, `MobileDashboardService.cs:11` | Job counts and "today" labels may differ between local and remote mode near timezone boundaries. |

---

## Steps to Remediation

### Critical Issues

**C1 — Hardcoded Credentials:**
- Remove hardcoded password from `MauiProgram.cs`. Read the initial admin password from a secure configuration source (environment variable, MAUI SecureStorage, or first-run setup prompt).
- Ensure `.env`, `.env.development`, and `.env.production` are all gitignored and never committed.
- Rotate any credentials that have been committed to version control history.

**C2 — TLS Bypass:**
- Wrap the `ServerCertificateCustomValidationCallback` bypass in `#if DEBUG` preprocessor directives so it only applies in debug builds.
- For production release builds, use proper certificate validation. If self-signed certs are needed for LAN deployments, implement certificate pinning or allow users to explicitly trust specific certificates.

**C3 — Destructive Schema Migration:**
- Implement EF Core Migrations (`dotnet ef migrations add`) instead of `EnsureDeleted()`/`EnsureCreated()`.
- For SQLite specifically, implement column-addition migration using `ALTER TABLE ADD COLUMN` statements.
- Before any schema migration, create a backup copy of the database file.
- Add a user-visible prompt before any destructive operation.

**C4 — IDOR on API Endpoints:**
- Implement resource-level authorization on all API endpoints. Each controller method should verify that the authenticated user (from JWT claims) has permission to access the requested resource.
- For Tech-role users, restrict data access to only their assigned jobs, their own time entries, and their own notes.
- Remove the `elevated` query parameter from the Dashboard API — derive elevation from the JWT role claim.

**C5 — Weak JWT Key:**
- Require `JWT_SECRET` environment variable in production (fail startup if not set).
- Generate a cryptographically random 256-bit key for the secret, not a derivation of machine name.
- Document the requirement to set `JWT_SECRET` in deployment guides.

### High Issues

**H1 — DbContext Lifetime:** Register `AppDbContext` as transient in MAUI, or create a `DbContextFactory` pattern using `AddDbContextFactory<AppDbContext>`.

**H2 — Concurrency Control:** Add a `[Timestamp]` property (`byte[] RowVersion`) to all entities that support sync, and configure `IsRowVersion()` in `OnModelCreating`.

**H3 — Audit Logging:** Implement audit logging in mobile services — override `SaveChangesAsync` in `AppDbContext` to automatically create `AuditLog` entries for all tracked changes.

**H4 — Hard Deletes:** Change all mobile delete operations to soft-delete (set `IsArchived = true`) to match the sync API pattern. Add a "purge" function for admin use only.

**H5 — Input Validation:** Add `[Required]`, `[StringLength]`, and `[Range]` data annotations to all entity models. Add `[ApiController]`-level model validation (already present via base class). Add FluentValidation or custom validation for business rules.

**H6 — Login Response Codes:** Return HTTP 401 for authentication failures instead of 200 with a failure payload.

**H7 — Sync Password Comparison:** Use `CryptographicOperations.FixedTimeEquals` for sync password comparison, or hash the sync password and compare hashes.

**H8 — Rate Limiting:** Add ASP.NET Core rate limiting middleware (`builder.Services.AddRateLimiter()`) with per-IP and per-user limits on auth and data endpoints.

**H9 — CSRF:** Re-enable anti-forgery on the login endpoint, or implement a proper CSRF token flow.

**H10 — Badge Performance:** Cache badge counts with a short TTL, or use an event-driven pattern to update counts only when data changes.

**H11 — Pagination:** Implement pagination on all sync GET endpoints using `Skip`/`Take` with the existing `SyncRequest.Page`/`PageSize` parameters.

### Medium Issues

**M1:** Implement EF Core Migrations for both projects. **M2:** Unify `EmployeeRole` and `UserRole` into a single enum, or add `Apprentice` to `UserRole`. **M6:** Use SQLite or a file for offline queue instead of Preferences. **M7:** Check API response status in `ReplayPostAsync` before returning true. **M9:** Implement password complexity requirements (minimum 8 chars, mixed case, digit, special). **M10:** Add HTTPS enforcement in production. **M14:** Add `UpdatedAt` to `TimeEntry` model and use it in sync delta queries.

### Low Issues

**L1:** Remove or obfuscate sensitive data in debug logging. **L6:** Add `.env.development` and `.env.production` to `.gitignore`. **L9:** Add `PRAGMA integrity_check` on startup. **L12:** Explicitly configure `ServiceAgreement.Site` FK in `OnModelCreating`.

---

I have not modified, suggested, or written any corrected code — only identified and described issues.
